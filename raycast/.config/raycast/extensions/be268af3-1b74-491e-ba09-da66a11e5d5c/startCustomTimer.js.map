{
  "version": 3,
  "sources": ["../src/startCustomTimer.tsx", "../src/soundData.ts", "../src/timerUtils.ts", "../src/formatUtils.ts"],
  "sourcesContent": ["import { Action, ActionPanel, closeMainWindow, Form, getPreferenceValues, Toast } from \"@raycast/api\";\nimport { useState } from \"react\";\nimport { soundData } from \"./soundData\";\nimport { checkForOverlyLoudAlert, createCustomTimer, ensureCTFileExists, startTimer } from \"./timerUtils\";\nimport { CTInlineArgs, InputField, RayFormEvent, Values } from \"./types\";\n\nexport default function CustomTimerView(props: { arguments: CTInlineArgs }) {\n  const hasArgs = Object.values(props.arguments).some((x) => x !== \"\");\n  const [hourErr, setHourErr] = useState<string | undefined>();\n  const [minErr, setMinErr] = useState<string | undefined>();\n  const [secErr, setSecErr] = useState<string | undefined>();\n\n  const prefs = getPreferenceValues();\n\n  const handleSubmit = (values: Values) => {\n    ensureCTFileExists();\n    if (values.hours === \"\" && values.minutes === \"\" && values.seconds === \"\") {\n      const toast = new Toast({ style: Toast.Style.Failure, title: \"No values set for timer length!\" });\n      toast.show();\n    } else if (isNaN(Number(values.hours))) {\n      setHourErr(\"Hours must be a number!\");\n    } else if (isNaN(Number(values.minutes))) {\n      setMinErr(\"Minutes must be a number!\");\n    } else if (isNaN(Number(values.seconds))) {\n      setSecErr(\"Seconds must be a number!\");\n    } else {\n      if (!checkForOverlyLoudAlert()) return;\n      closeMainWindow();\n      const timerName = values.name ? values.name : \"Untitled\";\n      const timeInSeconds = 3600 * Number(values.hours) + 60 * Number(values.minutes) + Number(values.seconds);\n      startTimer(timeInSeconds, timerName, values.selectedSound);\n      if (values.willBeSaved)\n        createCustomTimer({ name: values.name, timeInSeconds: timeInSeconds, selectedSound: values.selectedSound });\n    }\n  };\n\n  const dropHourErrorIfNeeded = () => {\n    if (hourErr && hourErr.length > 0) {\n      setHourErr(undefined);\n    }\n  };\n\n  const dropMinErrorIfNeeded = () => {\n    if (minErr && minErr.length > 0) {\n      setMinErr(undefined);\n    }\n  };\n\n  const dropSecErrorIfNeeded = () => {\n    if (secErr && secErr.length > 0) {\n      setSecErr(undefined);\n    }\n  };\n\n  const hourValidator = (event: RayFormEvent) => {\n    const input = event.target.value;\n    if (isNaN(Number(input))) {\n      setHourErr(\"Hours must be a number!\");\n    } else {\n      dropHourErrorIfNeeded();\n    }\n  };\n\n  const minValidator = (event: RayFormEvent) => {\n    const input = event.target.value;\n    if (isNaN(Number(input))) {\n      setMinErr(\"Minutes must be a number!\");\n    } else {\n      dropMinErrorIfNeeded();\n    }\n  };\n\n  const secValidator = (event: RayFormEvent) => {\n    const input = event.target.value;\n    if (isNaN(Number(input))) {\n      setSecErr(\"Seconds must be a number!\");\n    } else {\n      dropSecErrorIfNeeded();\n    }\n  };\n\n  const inputFields: InputField[] = [\n    {\n      id: \"hours\",\n      title: \"Hours\",\n      placeholder: \"0\",\n      err: hourErr,\n      drop: dropHourErrorIfNeeded,\n      validator: hourValidator,\n    },\n    {\n      id: \"minutes\",\n      title: \"Minutes\",\n      placeholder: \"00\",\n      err: minErr,\n      drop: dropMinErrorIfNeeded,\n      validator: minValidator,\n    },\n    {\n      id: \"seconds\",\n      title: \"Seconds\",\n      placeholder: \"00\",\n      err: secErr,\n      drop: dropSecErrorIfNeeded,\n      validator: secValidator,\n    },\n  ];\n  const sortOrder = prefs.newTimerInputOrder;\n  sortOrder !== \"hhmmss\" ? inputFields.reverse() : inputFields;\n\n  return (\n    <Form\n      actions={\n        <ActionPanel>\n          <Action.SubmitForm title=\"Start Custom Timer\" onSubmit={(values: Values) => handleSubmit(values)} />\n        </ActionPanel>\n      }\n    >\n      {inputFields.map((item, index) => (\n        <Form.TextField\n          key={index}\n          id={item.id}\n          title={item.title}\n          placeholder={item.placeholder}\n          defaultValue={props.arguments[item.id]}\n          error={item.err}\n          onChange={item.drop}\n          onBlur={item.validator}\n        />\n      ))}\n      <Form.Dropdown id=\"selectedSound\" defaultValue=\"default\" title=\"Sound\">\n        <Form.Dropdown.Item value=\"default\" title=\"Default\" />\n        {soundData.map((item, index) => (\n          <Form.Dropdown.Item\n            key={index}\n            title={item.value === prefs.selectedSound ? `${item.title} (currently selected)` : item.title}\n            value={item.value}\n            icon={item.icon}\n          />\n        ))}\n      </Form.Dropdown>\n      <Form.TextField id=\"name\" title=\"Name\" placeholder=\"Pour Tea\" autoFocus={hasArgs} />\n      <Form.Checkbox id=\"willBeSaved\" label=\"Save as preset\" />\n    </Form>\n  );\n}\n", "import { SoundData } from \"./types\";\nimport { Icon } from \"@raycast/api\";\n\nconst soundData: SoundData[] = [\n  {\n    title: \"Alarm Clock\",\n    icon: Icon.Alarm,\n    value: \"alarmClock.wav\",\n  },\n  {\n    title: \"Dismembered Woodpecker\",\n    icon: Icon.Bird,\n    value: \"dismemberedWoodpecker.wav\",\n  },\n  {\n    title: \"Flute Riff\",\n    icon: Icon.Music,\n    value: \"fluteRiff.wav\",\n  },\n  {\n    title: \"Level Up\",\n    icon: Icon.Trophy,\n    value: \"levelUp.wav\",\n  },\n  {\n    title: \"Piano Chime\",\n    icon: Icon.Music,\n    value: \"pianoChime.wav\",\n  },\n  {\n    title: \"Terminator\",\n    icon: Icon.BarCode,\n    value: \"terminator.wav\",\n  },\n  {\n    title: \"Speak Timer Name\",\n    icon: Icon.Person,\n    value: \"speak_timer_name\",\n  },\n];\nexport { soundData };\n", "import { environment, getPreferenceValues, popToRoot, showHUD, showToast, Toast } from \"@raycast/api\";\nimport { exec, execSync } from \"child_process\";\nimport { randomUUID } from \"crypto\";\nimport { existsSync, readdirSync, readFileSync, writeFileSync } from \"fs\";\nimport { extname } from \"path\";\nimport { CustomTimer, Preferences, Timer } from \"./types\";\nimport { formatTime, secondsBetweenDates } from \"./formatUtils\";\n\nconst DATAPATH = environment.supportPath + \"/customTimers.json\";\n\nconst checkForOverlyLoudAlert = (launchedFromMenuBar = false) => {\n  const prefs = getPreferenceValues<Preferences>();\n  if (parseFloat(prefs.volumeSetting) > 5.0) {\n    const errorMsg = \"\u26A0\uFE0F Timer alert volume should not be louder than 5 (it can get quite loud!)\";\n    if (launchedFromMenuBar) {\n      showHUD(errorMsg);\n    } else {\n      showToast({ style: Toast.Style.Failure, title: errorMsg });\n    }\n    return false;\n  }\n  return true;\n};\n\nasync function startTimer(timeInSeconds: number, timerName = \"Untitled\", selectedSound = \"default\") {\n  const fileName = environment.supportPath + \"/\" + new Date().toISOString() + \"---\" + timeInSeconds + \".timer\";\n  const masterName = fileName.replace(/:/g, \"__\");\n  writeFileSync(masterName, timerName);\n\n  const prefs = getPreferenceValues<Preferences>();\n  const selectedSoundPath = `${\n    environment.assetsPath + \"/\" + (selectedSound === \"default\" ? prefs.selectedSound : selectedSound)\n  }`;\n  const cmdParts = [`sleep ${timeInSeconds}`];\n  cmdParts.push(\n    `if [ -f \"${masterName}\" ]; then osascript -e 'display notification \"Timer \\\\\"${timerName}\\\\\" complete\" with title \"Ding!\"'`\n  );\n  const afplayString = `afplay \"${selectedSoundPath}\" --volume ${prefs.volumeSetting.replace(\",\", \".\")}`;\n  if (prefs.selectedSound === \"speak_timer_name\") {\n    cmdParts.push(`say \"${timerName}\"`);\n  } else {\n    cmdParts.push(afplayString);\n  }\n  if (prefs.ringContinuously) {\n    const dismissFile = `${masterName}`.replace(\".timer\", \".dismiss\");\n    writeFileSync(dismissFile, \".dismiss file for Timers\");\n    cmdParts.push(`while [ -f \"${dismissFile}\" ]; do ${afplayString}; done`);\n  }\n  cmdParts.push(`rm \"${masterName}\"; else echo \"Timer deleted\"; fi`);\n  exec(cmdParts.join(\" && \"), (error, stderr) => {\n    if (error) {\n      console.log(`error: ${error.message}`);\n      return;\n    }\n    if (stderr) {\n      console.log(`stderr: ${stderr}`);\n      return;\n    }\n  });\n  popToRoot();\n  await showHUD(`Timer \"${timerName}\" started for ${formatTime(timeInSeconds)}! \uD83C\uDF89`);\n}\n\nfunction stopTimer(timerFile: string) {\n  const deleteTimerCmd = `if [ -f \"${timerFile}\" ]; then rm \"${timerFile}\"; else echo \"Timer deleted\"; fi`;\n  const dismissFile = timerFile.replace(\".timer\", \".dismiss\");\n  const deleteDismissCmd = `if [ -f \"${dismissFile}\" ]; then rm \"${dismissFile}\"; else echo \"Timer deleted\"; fi`;\n  execSync(deleteTimerCmd);\n  execSync(deleteDismissCmd);\n}\n\nfunction getTimers() {\n  const setOfTimers: Timer[] = [];\n  const files = readdirSync(environment.supportPath);\n  files.forEach((timerFile: string) => {\n    if (extname(timerFile) == \".timer\") {\n      const timer: Timer = {\n        name: \"\",\n        secondsSet: -99,\n        timeLeft: -99,\n        originalFile: timerFile,\n        timeEnds: new Date(),\n      };\n      timer.name = readFileSync(environment.supportPath + \"/\" + timerFile).toString();\n      const timerFileParts = timerFile.split(\"---\");\n      timer.secondsSet = Number(timerFileParts[1].split(\".\")[0]);\n      const timeStarted = timerFileParts[0].replace(/__/g, \":\");\n      timer.timeLeft = Math.max(0, Math.round(timer.secondsSet - secondsBetweenDates({ d2: timeStarted })));\n      timer.timeEnds = new Date(timeStarted);\n      timer.timeEnds.setSeconds(timer.timeEnds.getSeconds() + timer.secondsSet);\n      setOfTimers.push(timer);\n    }\n  });\n  setOfTimers.sort((a, b) => {\n    return a.timeLeft - b.timeLeft;\n  });\n  return setOfTimers;\n}\n\nfunction renameTimer(timerFile: string, newName: string) {\n  const dataPath = environment.supportPath + \"/\" + timerFile;\n  writeFileSync(dataPath, newName);\n}\n\nfunction ensureCTFileExists() {\n  if (!existsSync(DATAPATH)) {\n    writeFileSync(DATAPATH, JSON.stringify({}));\n  }\n}\n\nfunction createCustomTimer(newTimer: CustomTimer) {\n  ensureCTFileExists();\n  const customTimers = JSON.parse(readFileSync(DATAPATH, \"utf8\"));\n  customTimers[randomUUID()] = newTimer;\n  writeFileSync(DATAPATH, JSON.stringify(customTimers));\n}\n\nfunction readCustomTimers() {\n  ensureCTFileExists();\n  return JSON.parse(readFileSync(DATAPATH, \"utf8\"));\n}\n\nfunction renameCustomTimer(ctID: string, newName: string) {\n  ensureCTFileExists();\n  const customTimers = JSON.parse(readFileSync(DATAPATH, \"utf8\"));\n  customTimers[ctID].name = newName;\n  writeFileSync(DATAPATH, JSON.stringify(customTimers));\n}\n\nfunction deleteCustomTimer(ctID: string) {\n  ensureCTFileExists();\n  const customTimers = JSON.parse(readFileSync(DATAPATH, \"utf8\"));\n  delete customTimers[ctID];\n  writeFileSync(DATAPATH, JSON.stringify(customTimers));\n}\n\nexport {\n  checkForOverlyLoudAlert,\n  createCustomTimer,\n  deleteCustomTimer,\n  ensureCTFileExists,\n  getTimers,\n  readCustomTimers,\n  renameTimer,\n  renameCustomTimer,\n  startTimer,\n  stopTimer,\n};\n", "const formatTime = (seconds: number) => {\n  const hours = Math.floor(seconds / 3600);\n  const mins = String(Math.floor((seconds % 3600) / 60)).padStart(2, \"0\");\n  const secs = String(Math.floor(seconds % 60)).padStart(2, \"0\");\n  return `${hours}:${mins}:${secs}`;\n};\n\nconst formatDateTime = (d: Date) => {\n  const parsedDate = new Date(d);\n  const datevalues = [\n    parsedDate.getFullYear().toString(),\n    parsedDate.getMonth().toString().padStart(2, \"0\"),\n    parsedDate.getDate().toString().padStart(2, \"0\"),\n  ];\n  const timevalues = [parsedDate.getHours(), parsedDate.getMinutes(), parsedDate.getSeconds()].map((x) =>\n    x.toString().padStart(2, \"0\")\n  );\n  const date = datevalues.join(\"-\");\n  const time = timevalues.join(\":\");\n  return `${date} ${time}`;\n};\n\nconst secondsBetweenDates = (args: { d1?: Date | string; d2?: Date | string }) => {\n  args.d1 = args.d1 == \"----\" ? undefined : args.d1;\n  args.d2 = args.d2 == \"----\" ? undefined : args.d2;\n  return (\n    Math.round(\n      (args.d1 ? new Date(args.d1) : new Date()).getTime() - (args.d2 ? new Date(args.d2) : new Date()).getTime()\n    ) / 1000\n  );\n};\n\nexport { formatTime, formatDateTime, secondsBetweenDates };\n"],
  "mappings": "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",
  "names": ["startCustomTimer_exports", "__export", "CustomTimerView", "__toCommonJS", "import_api", "import_react", "import_api", "soundData", "import_api", "import_child_process", "import_crypto", "import_fs", "formatTime", "seconds", "hours", "mins", "secs", "DATAPATH", "checkForOverlyLoudAlert", "launchedFromMenuBar", "prefs", "errorMsg", "startTimer", "timeInSeconds", "timerName", "selectedSound", "masterName", "selectedSoundPath", "cmdParts", "afplayString", "dismissFile", "error", "stderr", "formatTime", "ensureCTFileExists", "DATAPATH", "createCustomTimer", "newTimer", "customTimers", "import_jsx_runtime", "CustomTimerView", "props", "hasArgs", "x", "hourErr", "setHourErr", "minErr", "setMinErr", "secErr", "setSecErr", "prefs", "handleSubmit", "values", "ensureCTFileExists", "checkForOverlyLoudAlert", "timerName", "timeInSeconds", "startTimer", "createCustomTimer", "dropHourErrorIfNeeded", "dropMinErrorIfNeeded", "dropSecErrorIfNeeded", "inputFields", "event", "input", "item", "index", "soundData"]
}
