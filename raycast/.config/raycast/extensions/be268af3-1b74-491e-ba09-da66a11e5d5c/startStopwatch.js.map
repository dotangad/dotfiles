{
  "version": 3,
  "sources": ["../src/startStopwatch.ts", "../src/stopwatchUtils.ts"],
  "sourcesContent": ["import { closeMainWindow } from \"@raycast/api\";\nimport { startStopwatch } from \"./stopwatchUtils\";\nimport { SWInlineArgs } from \"./types\";\n\nexport default async (props: { arguments: SWInlineArgs }) => {\n  await closeMainWindow();\n  if (props.arguments.name) {\n    startStopwatch(props.arguments.name);\n  } else {\n    startStopwatch();\n  }\n};\n", "import { environment, popToRoot, showHUD } from \"@raycast/api\";\nimport { execSync } from \"child_process\";\nimport { randomUUID } from \"crypto\";\nimport { existsSync, readdirSync, readFileSync, writeFileSync } from \"fs\";\nimport { extname } from \"path\";\nimport { secondsBetweenDates } from \"./formatUtils\";\nimport { Stopwatch } from \"./types\";\n\nconst SWPATH = environment.supportPath + \"/raycast-stopwatches.json\";\n\nconst ensureSWFileExists = () => {\n  if (!existsSync(SWPATH) || readFileSync(SWPATH).toString() == \"\") {\n    writeFileSync(SWPATH, \"[]\");\n  }\n};\n\nconst initStopwatch = (swName = \"\"): Stopwatch => {\n  return {\n    name: swName,\n    swID: randomUUID(),\n    timeStarted: new Date(),\n    timeElapsed: -99,\n    lastPaused: \"----\",\n    pauseElapsed: 0,\n  };\n};\n\nconst processStopwatches = (swSet: Stopwatch[]) => {\n  swSet.map((x) => {\n    if (x.lastPaused != \"----\") {\n      x.timeElapsed = Math.max(0, secondsBetweenDates({ d1: x.lastPaused, d2: x.timeStarted }) - x.pauseElapsed);\n    } else {\n      const rawElapsedTime = Math.max(0, secondsBetweenDates({ d2: x.timeStarted }));\n      x.timeElapsed = rawElapsedTime - x.pauseElapsed;\n    }\n  });\n  return swSet;\n};\n\nconst getStopwatches = () => {\n  ensureSWFileExists();\n  const rawStopwatches: Stopwatch[] = JSON.parse(readFileSync(SWPATH).toString());\n  const fullStopwatchSet = cleanUpOldStopwatches(rawStopwatches);\n  const setOfStopwatches = processStopwatches(fullStopwatchSet);\n  setOfStopwatches.sort((a, b) => {\n    return a.timeElapsed - b.timeElapsed;\n  });\n  return setOfStopwatches;\n};\n\nconst startStopwatch = async (swName = \"Untitled\") => {\n  ensureSWFileExists();\n  const swStore: Stopwatch[] = JSON.parse(readFileSync(SWPATH).toString());\n  const newTimer = initStopwatch(swName);\n  swStore.push(newTimer);\n  writeFileSync(SWPATH, JSON.stringify(swStore));\n\n  popToRoot();\n  await showHUD(`Stopwatch \"${swName}\" started! \uD83C\uDF89`);\n};\n\nconst pauseStopwatch = (swToPause: string) => {\n  ensureSWFileExists();\n  let swStore: Stopwatch[] = JSON.parse(readFileSync(SWPATH).toString());\n  swStore = swStore.map((s) => (s.swID == swToPause ? { ...s, lastPaused: new Date() } : s));\n  writeFileSync(SWPATH, JSON.stringify(swStore));\n};\n\nconst unpauseStopwatch = (swToUnpause: string) => {\n  ensureSWFileExists();\n  let swStore: Stopwatch[] = JSON.parse(readFileSync(SWPATH).toString());\n  swStore = swStore.map((s) =>\n    s.swID == swToUnpause\n      ? {\n          ...s,\n          pauseElapsed: s.pauseElapsed + secondsBetweenDates({ d2: s.lastPaused }),\n          lastPaused: \"----\",\n        }\n      : s\n  );\n  writeFileSync(SWPATH, JSON.stringify(swStore));\n};\n\nconst stopStopwatch = (swToDelete: string) => {\n  ensureSWFileExists();\n  let swStore: Stopwatch[] = JSON.parse(readFileSync(SWPATH).toString());\n  swStore = swStore.filter((s: Stopwatch) => s.swID !== swToDelete);\n  writeFileSync(SWPATH, JSON.stringify(swStore));\n};\n\nconst cleanUpOldStopwatches = (newStore: Stopwatch[]) => {\n  const files = readdirSync(environment.supportPath);\n  files.forEach((swFile: string) => {\n    if (extname(swFile) == \".stopwatch\") {\n      const stopwatch = initStopwatch(readFileSync(environment.supportPath + \"/\" + swFile).toString());\n      const timeStarted = swFile.replace(/__/g, \":\").replace(\".stopwatch\", \"\");\n      stopwatch.timeStarted = new Date(timeStarted);\n      stopwatch.timeElapsed = Math.max(0, secondsBetweenDates({}));\n      execSync(`rm \"${environment.supportPath}/${swFile}\"`);\n      newStore.push(stopwatch);\n    }\n  });\n  writeFileSync(SWPATH, JSON.stringify(newStore));\n  return newStore;\n};\n\nconst renameStopwatch = (swID: string, newName: string) => {\n  ensureSWFileExists();\n  const stopwatches: Stopwatch[] = JSON.parse(readFileSync(SWPATH, \"utf8\"));\n  const renamedSW = stopwatches.map((x) => (x.swID == swID ? { ...x, name: newName } : x));\n  writeFileSync(SWPATH, JSON.stringify(renamedSW));\n};\n\nexport { getStopwatches, pauseStopwatch, unpauseStopwatch, startStopwatch, stopStopwatch, renameStopwatch };\n"],
  "mappings": "yaAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,aAAAE,IAAA,eAAAC,EAAAH,GAAA,IAAAI,EAAgC,wBCAhC,IAAAC,EAAgD,wBAEhD,IAAAC,EAA2B,kBAC3BC,EAAqE,cAKrE,IAAMC,EAAS,cAAY,YAAc,4BAEnCC,EAAqB,IAAM,EAC3B,IAAC,cAAWD,CAAM,MAAK,gBAAaA,CAAM,EAAE,SAAS,GAAK,QAC5D,iBAAcA,EAAQ,IAAI,CAE9B,EAEME,EAAgB,CAACC,EAAS,MACvB,CACL,KAAMA,EACN,QAAM,cAAW,EACjB,YAAa,IAAI,KACjB,YAAa,IACb,WAAY,OACZ,aAAc,CAChB,GA0BF,IAAMC,EAAiB,MAAOC,EAAS,aAAe,CACpDC,EAAmB,EACnB,IAAMC,EAAuB,KAAK,SAAM,gBAAaC,CAAM,EAAE,SAAS,CAAC,EACjEC,EAAWC,EAAcL,CAAM,EACrCE,EAAQ,KAAKE,CAAQ,KACrB,iBAAcD,EAAQ,KAAK,UAAUD,CAAO,CAAC,KAE7C,aAAU,EACV,QAAM,WAAQ,cAAcF,uBAAqB,CACnD,EDvDA,IAAOM,EAAQ,MAAOC,GAAuC,CAC3D,QAAM,mBAAgB,EAClBA,EAAM,UAAU,KAClBC,EAAeD,EAAM,UAAU,IAAI,EAEnCC,EAAe,CAEnB",
  "names": ["startStopwatch_exports", "__export", "startStopwatch_default", "__toCommonJS", "import_api", "import_api", "import_crypto", "import_fs", "SWPATH", "ensureSWFileExists", "initStopwatch", "swName", "startStopwatch", "swName", "ensureSWFileExists", "swStore", "SWPATH", "newTimer", "initStopwatch", "startStopwatch_default", "props", "startStopwatch"]
}
